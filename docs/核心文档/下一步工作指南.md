# 🎯 Jaaz 项目 - 下一步工作指南

> **更新时间**: 2025-11-13
> **优先级**: 立即执行

---

## 📊 user_data 下的 3 个数据库说明

### 数据库概览

```
server/user_data/
├── localmanus.db       # 8.5 MB - 主数据库（核心）
├── templates.db        # 28 KB  - 模板数据库（独立）
└── fonts.db            # 20 KB  - 字体数据库（独立）
```

---

### 1. **localmanus.db** - 主数据库 ⭐ 核心

**用途**: 存储应用的核心业务数据

**管理方式**:
- ✅ 自动迁移系统 (`server/services/migrations/`)
- ✅ 统一的 `db_service.py` 管理
- ✅ 当前版本: v7

**包含的表**:
```sql
-- 用户相关 (v4, v5, v7)
users                # 用户信息（本地账号 + Google OAuth）
device_codes         # Google OAuth 设备码
auth_tokens          # 认证令牌（JWT）

-- 画布相关 (v2, v6)
canvases             # 画布数据（关联 user_id）
chat_sessions        # 聊天会话（关联 canvas_id）
chat_messages        # 聊天消息（JSON 格式）

-- 工作流相关 (v3)
comfy_workflows      # ComfyUI 工作流配置

-- 系统表
db_version           # 数据库迁移版本号
```

**为什么是核心**:
- 前端 90% 的功能都依赖这个数据库
- 画布列表、聊天历史、用户登录都在这里
- 有完整的迁移系统和数据完整性保障

**代码位置**:
- 迁移文件: `server/services/migrations/v1_initial_schema.py ~ v7_add_user_role.py`
- 服务层: `server/services/db_service.py`

---

### 2. **templates.db** - 模板数据库 ⚠️ 独立系统

**用途**: 存储 PSD 模板的元数据

**管理方式**:
- ⚠️ **独立的数据库文件**（不在主迁移系统中）
- ⚠️ 使用 SQLAlchemy 直接操作
- ⚠️ 没有迁移系统

**创建位置**:
```python
# server/routers/psd_router.py:40
TEMPLATE_DB_URL = "sqlite:///./user_data/templates.db"

# 使用 SQLAlchemy 创建表
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Text, DateTime
from sqlalchemy.orm import sessionmaker

engine = create_engine(TEMPLATE_DB_URL)
metadata = MetaData()

# 定义模板表
template_table = Table(
    'templates', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(255), nullable=False),
    Column('description', Text),
    Column('file_path', String(512), nullable=False),
    Column('thumbnail_path', String(512)),
    Column('category', String(100)),
    Column('tags', Text),  # JSON 数组
    Column('created_at', DateTime),
    Column('updated_at', DateTime),
)

metadata.create_all(engine)  # 创建表
```

**为什么是独立的**:
1. **历史原因**: PSD 功能最初独立开发，使用了 SQLAlchemy
2. **数据隔离**: 模板数据可能非常大（包含 PSD 文件元数据）
3. **备份方便**: 可以单独备份/恢复模板数据

**当前问题**:
- ❌ `template_service.py` 尝试往主数据库 (`localmanus.db`) 写入，但主数据库没有 `templates` 表
- ❌ `psd_router.py` 使用独立的 `templates.db`，但两者不同步

**代码位置**:
- 数据库定义: `server/routers/psd_router.py:40-80`
- 服务层: `server/services/template_service.py` （但目前被禁用）

---

### 3. **fonts.db** - 字体数据库 ⚠️ 独立系统

**用途**: 存储字体文件的元数据

**管理方式**:
- ⚠️ **独立的数据库文件**
- ⚠️ 使用 SQLAlchemy 直接操作
- ⚠️ 没有迁移系统

**创建位置**:
```python
# server/routers/font_router.py:17
DATABASE_URL = "sqlite:///./user_data/fonts.db"

# 使用 SQLAlchemy 创建表
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, Boolean, DateTime

engine = create_engine(DATABASE_URL)
metadata = MetaData()

# 定义字体表
font_table = Table(
    'fonts', metadata,
    Column('id', Integer, primary_key=True),
    Column('name', String(255), nullable=False),
    Column('file_path', String(512), nullable=False),
    Column('family', String(255)),
    Column('style', String(100)),
    Column('is_system_font', Boolean, default=False),
    Column('created_at', DateTime),
)

metadata.create_all(engine)  # 创建表
```

**为什么是独立的**:
1. **功能独立**: 字体管理是独立的功能模块
2. **性能优化**: 字体扫描可能很慢，独立数据库避免影响主数据库
3. **备份方便**: 可以单独备份字体配置

**代码位置**:
- 数据库定义: `server/routers/font_router.py:17-50`
- 路由: `server/routers/font_router.py`

---

## 🚨 当前架构的问题

### 问题 1: 模板功能分裂

**现状**:
```
template_service.py  →  localmanus.db (没有 templates 表) ❌
psd_router.py        →  templates.db (有 templates 表) ✅
```

**后果**:
- 前端调用 `template_service` 的接口会报错
- `psd_router.py` 的模板功能可以工作，但被 `template_router.py` 覆盖

**解决方案**: 见下文 "下一步工作"

---

### 问题 2: 数据库管理不统一

**现状**:
```
localmanus.db  →  有迁移系统  ✅
templates.db   →  无迁移系统  ❌
fonts.db       →  无迁移系统  ❌
```

**后果**:
- 难以升级数据库结构
- 数据一致性难以保证
- 部署复杂度增加

---

## 🎯 下一步工作 - 优先级排序

### 优先级 P0 - 立即执行（本周完成）

#### 1. 统一模板数据库架构 (最重要) ⭐⭐⭐

**问题**: 模板功能分裂，前后端对接混乱

**方案 A: 迁移到主数据库** (推荐)
```python
# 创建 server/services/migrations/v8_create_templates_table.py
class V8CreateTemplatesTable(Migration):
    def up(self, cursor):
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS templates (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                description TEXT,
                file_path TEXT NOT NULL,
                file_type TEXT NOT NULL,
                file_size INTEGER,
                thumbnail_path TEXT,
                category TEXT,
                tags TEXT,  -- JSON 数组
                created_by TEXT NOT NULL,
                created_at TEXT NOT NULL,
                updated_at TEXT NOT NULL,
                FOREIGN KEY (created_by) REFERENCES users(id)
            )
        ''')

        # 迁移旧数据
        cursor.execute('''
            ATTACH DATABASE './user_data/templates.db' AS old_templates
        ''')
        cursor.execute('''
            INSERT INTO templates
            SELECT * FROM old_templates.templates
        ''')
        cursor.execute('DETACH DATABASE old_templates')
```

**优点**:
- ✅ 统一到主迁移系统
- ✅ 数据一致性保证
- ✅ 简化代码逻辑

**缺点**:
- ⚠️ 需要迁移旧数据
- ⚠️ 主数据库文件变大

**工作量**: 4 小时

---

**方案 B: 保持独立但统一接口** (备选)
```python
# server/services/template_service.py
class TemplateService:
    def __init__(self):
        # 使用独立的 templates.db
        self.db_path = "user_data/templates.db"

    async def list_templates(self):
        async with aiosqlite.connect(self.db_path) as db:
            # 查询 templates.db 而不是 localmanus.db
            ...
```

**优点**:
- ✅ 保持数据隔离
- ✅ 改动量小

**缺点**:
- ❌ 数据库管理仍然分裂
- ❌ 无迁移系统

**工作量**: 2 小时

---

**建议**: **选择方案 A** - 长期来看更健康

**实施步骤**:
1. 创建 `v8_create_templates_table.py` 迁移文件
2. 从 `templates.db` 迁移数据到 `localmanus.db`
3. 更新 `template_service.py` 使用主数据库
4. 删除 `psd_router.py` 中的模板相关代码（已有 `template_router.py`）
5. 取消 `template_router.py` 中的禁用代码
6. 测试前后端联调

---

#### 2. 前端测试核心功能 (重要) ⭐⭐

**目标**: 验证前后端联调是否正常

**测试清单**:

**2.1 画布功能测试**
```bash
# 1. 启动后端
cd server
python main.py

# 2. 启动前端
cd react
npm run dev

# 3. 测试步骤
- 打开 http://localhost:5173
- 登录账号（或游客模式）
- 创建新画布 ✅
- 在画布中添加元素（文本/图片/形状）✅
- 保存画布 ✅
- 刷新页面，数据是否保留 ✅
- 返回首页，画布是否在列表中 ✅
```

**预期结果**: 全部通过 ✅

---

**2.2 AI 聊天功能测试**
```bash
# 测试步骤
- 打开画布
- 打开右侧聊天面板
- 输入: "画一张猫的图片"
- 等待 AI 响应（5-30秒）
- 检查是否生成图片 ✅
- 检查图片是否显示在画布中 ✅
- 刷新页面，聊天记录是否保留 ✅
```

**预期结果**:
- ✅ AI 响应正常
- ✅ 图片生成成功
- ⚠️ 图片可能不会自动显示（已知问题，见下文）

---

**2.3 用户认证测试**
```bash
# 测试步骤
- 点击右上角"登录"
- 选择"本地账号登录"
- 输入用户名/密码（或注册新账号）
- 登录成功 ✅
- 检查画布列表是否只显示自己的画布 ✅
- 退出登录 ✅
- 以游客身份浏览（只读模式）✅
```

**预期结果**: 全部通过 ✅

---

#### 3. 修复图片显示问题 (高优先级) ⭐⭐

**问题**: 图片生成成功，但前端不自动显示

**原因分析**:

**可能原因 1**: 前端未监听 `image_generated` WebSocket 事件
```typescript
// react/src/components/canvas/CanvasExcali.tsx
// 检查是否有这段代码
socket?.on('message', (data) => {
  if (data.type === 'image_generated') {
    // 将图片添加到画布
    const newElement = {
      type: 'image',
      x: 100,
      y: 100,
      width: data.width,
      height: data.height,
      fileId: data.file_id,
    }
    excalidrawAPI.addElement(newElement)
  }
})
```

**可能原因 2**: 后端发送的事件格式不正确
```python
# server/services/langgraph_service/StreamProcessor.py
# 检查是否有这段代码
await self.websocket_service(self.session_id, {
    'type': 'image_generated',
    'file_id': file_id,
    'width': width,
    'height': height,
    'url': f'/api/file/{file_id}'
})
```

**修复步骤**:
1. 检查后端是否发送 `image_generated` 事件
2. 检查前端是否监听该事件
3. 添加调试日志查看事件流
4. 修复前端代码，自动将图片添加到画布

**工作量**: 3 小时

---

### 优先级 P1 - 本月完成

#### 4. 修复竞态条件 (重要)

**问题**: 服务启动时用户立即发送请求可能崩溃

**解决方案**: 见 [项目规划.md](./项目规划.md) Phase 1.2

**工作量**: 3 小时

---

#### 5. WebSocket 消息隔离 (重要)

**问题**: 所有用户收到相同的 WebSocket 消息

**解决方案**: 见 [项目规划.md](./项目规划.md) Phase 1.3

**工作量**: 6 小时

---

### 优先级 P2 - 下月完成

#### 6. 视频编辑器

**详见**: [项目规划.md](./项目规划.md) Phase 2.1

**工作量**: 40 小时 (2 周)

---

## 📊 本周工作计划（2025-11-14 ~ 11-20）

### Monday - Tuesday (2天)
- ✅ 统一模板数据库架构（方案 A）
- ✅ 创建 v8 迁移文件
- ✅ 迁移旧数据

### Wednesday (1天)
- ✅ 前端测试核心功能
- ✅ 修复图片显示问题

### Thursday - Friday (2天)
- ✅ 修复竞态条件
- ✅ 清理调试日志
- ✅ 编写单元测试

### 周末（可选）
- 📝 更新文档
- 📝 准备 v1.0.31 发布

---

## 🎯 成功指标

### 本周目标
- ✅ 模板功能完全恢复
- ✅ 前端核心功能测试通过率 100%
- ✅ 图片生成后自动显示
- ✅ 无竞态条件崩溃
- ✅ 代码质量评级 > B

### 验收标准
1. 用户可以创建/编辑/删除模板 ✅
2. 画布功能完全正常 ✅
3. AI 聊天生成图片自动显示 ✅
4. 并发 100 个请求不崩溃 ✅
5. 调试日志减少 80% ✅

---

## 💡 推荐的执行顺序

```
1. 统一模板数据库 (P0) ⭐⭐⭐
   ↓
2. 前端测试核心功能 (P0) ⭐⭐
   ↓
3. 修复图片显示 (P0) ⭐⭐
   ↓
4. 修复竞态条件 (P1)
   ↓
5. WebSocket 消息隔离 (P1)
   ↓
6. 视频编辑器 (P2)
```

---

**关键点**:

1. **先修复模板数据库** - 这是前后端对接的核心问题
2. **然后测试核心功能** - 验证基础功能是否正常
3. **最后优化细节** - 修复已知的小问题

---

*最后更新: 2025-11-13*

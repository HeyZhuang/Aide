# 技术细节与最佳实践指南

## 🔧 关键技术实现细节

### 1. WebSocket实时通信架构

#### 后端实现 (`websocket_service.py`, `websocket_state.py`)

**Socket.IO集成**:
- 使用`python-socketio`作为ASGI应用集成到FastAPI
- 支持WebSocket和HTTP长轮询降级
- 事件驱动的消息推送

**关键特性**:
- 会话管理：每个客户端有独立的session_id
- 消息路由：根据session_id定向推送
- 连接状态跟踪：实时监控客户端连接状态

#### 前端实现 (`lib/socket.ts`)

**连接管理**:
- 自动重连机制（最多3次）
- 连接超时处理（10秒）
- 事件总线集成（mitt）

**消息处理**:
- 类型安全的消息接口
- 事件订阅/取消订阅
- 错误处理和重试

### 2. AI Agent系统架构

#### LangGraph多Agent系统

**架构设计**:
```
用户消息
  ↓
Planner Agent (规划任务)
  ↓
Image Designer Agent (图像设计)
  ↓
Video Designer Agent (视频设计)
  ↓
工具执行 (图像/视频生成)
  ↓
结果返回
```

**关键组件**:
- `langgraph_service/agent_service.py`: Agent核心逻辑
- `langgraph_service/configs/`: 各Agent配置
- `services/tool_service.py`: 工具注册和管理

**工具系统**:
- 统一工具接口抽象
- 动态工具注册
- 工具确认机制（`tool_confirmation_manager.py`）

### 3. 数据库迁移系统

#### 迁移管理器 (`services/migrations/manager.py`)

**设计特点**:
- 版本化迁移
- 自动检测和执行
- 支持回滚（down方法）

**迁移流程**:
1. 检查当前数据库版本
2. 比较目标版本
3. 按顺序执行迁移
4. 更新版本号

**最佳实践**:
- 每个迁移文件只做一件事
- 迁移应该是幂等的
- 始终提供down方法用于回滚

### 4. 配置管理系统

#### 配置服务 (`config_service.py`)

**配置存储**:
- TOML格式配置文件
- 用户数据目录（`user_data/config.toml`）
- 默认配置和用户配置合并

**配置结构**:
```toml
[provider_name]
url = "https://api.example.com"
api_key = "your-api-key"
max_tokens = 8192

[provider_name.models]
model_name = { type = "text" }
```

**配置管理**:
- 动态加载和更新
- 配置验证
- 默认值处理

### 5. PSD处理流程

#### PSD解析 (`utils/psd_layer_info.py`)

**处理步骤**:
1. 使用`psd-tools`解析PSD文件
2. 递归遍历图层树
3. 提取图层信息（位置、尺寸、可见性等）
4. 导出图层为PNG（保留透明通道）

#### 智能缩放 (`gemini_psd_resize_service.py`)

**AI分析流程**:
1. 构建图层信息JSON
2. 发送到Gemini 2.5 Pro分析
3. 获取缩放参数建议
4. 应用变换到图层
5. 重建PSD文件

**关键提示词工程**:
- 详细的图层信息描述
- 明确的缩放规则
- 视觉平衡要求

### 6. 图像/视频生成提供商系统

#### Provider接口设计

**基类** (`image_base_provider.py`, `video_base_provider.py`):
- 统一的生成接口
- 错误处理规范
- 进度回调支持

**实现示例**:
```python
class CustomProvider(ImageBaseProvider):
    async def generate(self, prompt, **kwargs):
        # 实现生成逻辑
        pass
```

**注册机制**:
- 在`tool_service.py`中注册
- 支持动态启用/禁用
- 配置驱动

---

## 🎯 最佳实践

### 1. 添加新功能的标准流程

#### 后端功能添加

**步骤1: 创建数据模型** (如需要)
```python
# models/your_model.py
from pydantic import BaseModel

class YourModel(BaseModel):
    field1: str
    field2: int
```

**步骤2: 创建服务层**
```python
# services/your_service.py
class YourService:
    async def do_something(self, data):
        # 业务逻辑
        pass
```

**步骤3: 创建路由**
```python
# routers/your_router.py
from fastapi import APIRouter
from services.your_service import your_service

router = APIRouter(prefix="/api/your")

@router.post("/endpoint")
async def your_endpoint(data: YourModel):
    result = await your_service.do_something(data)
    return result
```

**步骤4: 注册路由**
```python
# main.py
from routers import your_router
app.include_router(your_router.router)
```

#### 前端功能添加

**步骤1: 创建API函数**
```typescript
// api/your.ts
export async function yourApi(data: YourModel) {
  const response = await fetch('/api/your/endpoint', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data)
  })
  return await response.json()
}
```

**步骤2: 创建组件**
```typescript
// components/your/YourComponent.tsx
export function YourComponent() {
  // 组件逻辑
}
```

**步骤3: 创建路由页面** (如需要)
```typescript
// routes/your-page.tsx
export const Route = createFileRoute('/your-page')({
  component: YourPage
})
```

### 2. 错误处理规范

#### 后端错误处理

```python
from fastapi import HTTPException
from utils.logger import get_logger

logger = get_logger("your_module")

try:
    # 业务逻辑
    result = await do_something()
except ValueError as e:
    logger.error(f"业务错误: {e}")
    raise HTTPException(status_code=400, detail=str(e))
except Exception as e:
    logger.error(f"未知错误: {e}", exc_info=True)
    raise HTTPException(status_code=500, detail="内部服务器错误")
```

#### 前端错误处理

```typescript
try {
  const result = await yourApi(data)
  // 处理成功
} catch (error) {
  if (error instanceof Error) {
    toast.error(error.message)
  } else {
    toast.error('操作失败，请稍后重试')
  }
}
```

### 3. 日志记录规范

#### 使用统一的日志系统

```python
from utils.logger import get_logger

logger = get_logger("your_module")

# 不同级别的日志
logger.debug("调试信息")
logger.info("一般信息")
logger.warning("警告信息")
logger.error("错误信息", exc_info=True)  # exc_info=True包含堆栈跟踪
```

#### 日志内容建议

- **调试**: 详细的执行流程
- **信息**: 重要的业务事件（用户登录、操作完成等）
- **警告**: 非致命问题（配置缺失、降级处理等）
- **错误**: 异常和失败（包含堆栈跟踪）

### 4. 数据库操作规范

#### 使用异步数据库操作

```python
async with aiosqlite.connect(db_service.db_path) as db:
    db.row_factory = aiosqlite.Row  # 使用Row工厂
    cursor = await db.execute("SELECT * FROM table WHERE id = ?", (id,))
    row = await cursor.fetchone()
    if row:
        result = dict(row)  # 转换为字典
```

#### 事务处理

```python
async with aiosqlite.connect(db_service.db_path) as db:
    try:
        await db.execute("INSERT INTO ...")
        await db.execute("UPDATE ...")
        await db.commit()  # 提交事务
    except Exception as e:
        await db.rollback()  # 回滚
        raise
```

### 5. WebSocket消息格式规范

#### 消息类型定义

```typescript
// types/socket.ts
export interface SocketMessage {
  type: 'message' | 'tool_result' | 'done' | 'error'
  session_id: string
  data: any
}
```

#### 发送消息

```python
# 后端
await send_to_websocket(session_id, {
    'type': 'message',
    'content': '...',
    'role': 'assistant'
})
```

#### 接收消息

```typescript
// 前端
socketManager.on('message', (data) => {
  if (data.type === 'message') {
    // 处理消息
  }
})
```

### 6. 类型安全

#### TypeScript类型定义

```typescript
// types/types.ts
export interface YourType {
  id: string
  name: string
  optional?: string
}

// 使用
const data: YourType = {
  id: '123',
  name: 'test'
}
```

#### Python类型提示

```python
from typing import Optional, List, Dict, Any

def your_function(
    param1: str,
    param2: Optional[int] = None,
    param3: List[str] = []
) -> Dict[str, Any]:
    # 函数实现
    return {}
```

### 7. 性能优化建议

#### 前端优化

- **代码分割**: 使用React.lazy和Suspense
- **缓存策略**: 合理使用React Query缓存
- **防抖节流**: 对频繁操作使用防抖（如搜索）
- **虚拟滚动**: 长列表使用虚拟滚动

#### 后端优化

- **异步操作**: 使用async/await避免阻塞
- **数据库索引**: 为常用查询字段添加索引
- **连接池**: 数据库连接复用
- **缓存**: 对频繁访问的数据使用缓存

### 8. 测试建议

#### 单元测试

```python
# test_your_service.py
import pytest
from services.your_service import YourService

@pytest.mark.asyncio
async def test_your_function():
    service = YourService()
    result = await service.your_function("test")
    assert result == expected
```

#### 集成测试

```python
# test_your_api.py
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_your_endpoint():
    response = client.post("/api/your/endpoint", json={"field": "value"})
    assert response.status_code == 200
```

---

## 🚨 常见问题和解决方案

### 1. WebSocket连接失败

**问题**: 前端无法连接到WebSocket服务器

**解决方案**:
- 检查后端Socket.IO服务是否启动
- 确认CORS配置正确
- 检查防火墙设置
- 查看浏览器控制台错误信息

### 2. PSD处理失败

**问题**: PSD文件无法解析或处理

**解决方案**:
- 确认`psd-tools`已安装
- 检查PSD文件是否损坏
- 查看日志了解具体错误
- 确认文件大小在合理范围内

### 3. AI生成超时

**问题**: 图像/视频生成请求超时

**解决方案**:
- 增加超时时间设置
- 检查API密钥是否有效
- 确认网络连接正常
- 查看提供商服务状态

### 4. 数据库迁移失败

**问题**: 数据库迁移执行失败

**解决方案**:
- 检查数据库文件权限
- 确认迁移文件语法正确
- 查看迁移日志了解错误
- 手动执行SQL修复（如需要）

### 5. 配置丢失

**问题**: 配置修改后丢失

**解决方案**:
- 确认配置文件路径正确
- 检查文件写入权限
- 查看配置服务日志
- 备份配置文件

---

## 📚 扩展阅读

### 相关文档

- `README.md` - 项目概述
- `AUTH_SYSTEM_README.md` - 认证系统说明
- `PSD_AUTO_RESIZE_GUIDE.md` - PSD缩放指南
- `TEMPLATE_MANAGEMENT_SYSTEM.md` - 模板系统说明

### 技术文档

- [FastAPI文档](https://fastapi.tiangolo.com/)
- [LangGraph文档](https://langchain-ai.github.io/langgraph/)
- [Socket.IO文档](https://socket.io/docs/)
- [TanStack Router文档](https://tanstack.com/router)

---

*最后更新: 2025年*

